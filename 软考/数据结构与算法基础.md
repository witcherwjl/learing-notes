

# 数据结构与算法基础

![image-20200501015050371](数据结构与算法基础.assets/image-20200501015050371.png)

## 数组

![image-20200501015116952](数据结构与算法基础.assets/image-20200501015116952.png)

- 二维中有按列存储和按行存储
- 按行：先满足一行，再开一列
- 答案：$ a+(2*5+3)*2 $

## 稀疏矩阵

![image-20200501020152647](数据结构与算法基础.assets/image-20200501020152647.png)

- 计算将稀疏矩阵转为一维矩阵对应的位置

## 线性表

![image-20200501020340535](数据结构与算法基础.assets/image-20200501020340535.png)

### 顺序存储和链式存储对比

![image-20200501020514724](数据结构与算法基础.assets/image-20200501020514724.png)

### 队列和栈

![image-20200501020553020](数据结构与算法基础.assets/image-20200501020553020.png)

## 广义表

![image-20200501024546212](数据结构与算法基础.assets/image-20200501024546212.png)

## 树与二叉树

![image-20200501024620358](数据结构与算法基础.assets/image-20200501024620358.png)

![image-20200501024717888](数据结构与算法基础.assets/image-20200501024717888.png)

### 二叉树遍历

### 树转二叉树

最左子树为左子树，兄弟为右子树

![image-20200501025346461](数据结构与算法基础.assets/image-20200501025346461.png)

### 查找二叉树

1. 二叉排序树，左孩子小于根，右孩子大于根

![image-20200501025612024](数据结构与算法基础.assets/image-20200501025612024.png)

### 最优二叉树（哈夫曼树）

构造：从最小的两个开始，然后求和得到新的节点。再寻找最小的两个，循环重复。

- 使值越大的越接近根

![image-20200501025950047](数据结构与算法基础.assets/image-20200501025950047.png)

### 线索二叉树

![image-20200501030238286](数据结构与算法基础.assets/image-20200501030238286.png)

### 平衡二叉树

![image-20200501030324855](数据结构与算法基础.assets/image-20200501030324855.png)

## 图

## 完全图

![image-20200501030422305](数据结构与算法基础.assets/image-20200501030422305.png)

## 邻接矩阵

![image-20200501030502494](数据结构与算法基础.assets/image-20200501030502494.png)

## 邻接表

![image-20200501030544766](数据结构与算法基础.assets/image-20200501030544766.png)

### 图的遍历

![image-20200501030702805](数据结构与算法基础.assets/image-20200501030702805.png)

### 图的最小生成树

![image-20200501030854038](数据结构与算法基础.assets/image-20200501030854038.png)